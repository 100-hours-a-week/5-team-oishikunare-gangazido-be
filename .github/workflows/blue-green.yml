on:
  push:
    branches:
      - feature/map

name: ğŸš€ Blue-Green Deployment (Stable)

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'corretto'
          java-version: '17'

      - name: Ensure JAVA_HOME is set correctly
        run: echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV

      - name: Debug JAVA_HOME
        run: echo $JAVA_HOME  # í˜„ì¬ JAVA_HOME ê²½ë¡œ ì¶œë ¥ (ë””ë²„ê¹…ìš©)

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true

      - name: Build Spring Boot Application
        run: |
          chmod +x gradlew
          ./gradlew clean bootJar

      - name: Ensure JAR File Exists
        run: |
          ls -lh build/libs/
          if [ ! -f build/libs/*.jar ]; then
            echo "ğŸš¨ JAR íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¹Œë“œë¥¼ í™•ì¸í•˜ì„¸ìš”!"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine Active Environment
        id: active_env
        run: |
          echo "ğŸ” í˜„ì¬ íŠ¸ë˜í”½ì„ ë°›ê³  ìˆëŠ” Target Groupì„ í™•ì¸ ì¤‘..."

          CURRENT_ACTIVE_TARGET_GROUP=$(aws elbv2 describe-rules \
          --listener-arn ${{ secrets.ALB_LISTENER_ARN }} \
          --region ap-northeast-2 \
          --query 'Rules[?Conditions[?Field==`host-header` && Values[0]==`api.gangazido.com`]].Actions[0].ForwardConfig.TargetGroups' \
          --output json | \
          grep -B1 '"Weight": 1' | grep 'TargetGroupArn' | head -n1 | \
          sed 's/.*"TargetGroupArn": "\(.*\)",/\1/')

          echo "í˜„ì¬ í™œì„±í™”ëœ Target Group ARN: $CURRENT_ACTIVE_TARGET_GROUP"

          if [[ "$CURRENT_ACTIVE_TARGET_GROUP" == "${{ secrets.BLUE_TARGET_GROUP_ARN }}" ]]; then
          echo "âœ… BLUEê°€ í™œì„±í™”ë¨, GREENì— ë°°í¬"
          echo "DEPLOY_ENV=GREEN" >> $GITHUB_ENV
          echo "NEW_ASG=gangazido-prod-green" >> $GITHUB_ENV
          echo "NEW_TARGET_GROUP=${{ secrets.GREEN_TARGET_GROUP_ARN }}" >> $GITHUB_ENV
          echo "OLD_ASG=gangazido-prod-blue" >> $GITHUB_ENV
          echo "OLD_ASG_TARGET_GROUP=${{ secrets.BLUE_TARGET_GROUP_ARN }}" >> $GITHUB_ENV
          elif [[ "$CURRENT_ACTIVE_TARGET_GROUP" == "${{ secrets.GREEN_TARGET_GROUP_ARN }}" ]]; then
          echo "âœ… GREENì´ í™œì„±í™”ë¨, BLUEì— ë°°í¬"
          echo "DEPLOY_ENV=BLUE" >> $GITHUB_ENV
          echo "NEW_ASG=gangazido-prod-blue" >> $GITHUB_ENV
          echo "NEW_TARGET_GROUP=${{ secrets.BLUE_TARGET_GROUP_ARN }}" >> $GITHUB_ENV
          echo "OLD_ASG=gangazido-prod-green" >> $GITHUB_ENV
          echo "OLD_ASG_TARGET_GROUP=${{ secrets.GREEN_TARGET_GROUP_ARN }}" >> $GITHUB_ENV
          else
          echo "ğŸš¨ í™œì„±í™”ëœ Target Groupì„ íŒë³„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          exit 1
          fi

      - name: Debug Deployment Variables
        run: |
          echo "ğŸš€ ë°°í¬ ëŒ€ìƒ ASG: $NEW_ASG"
          echo "ğŸ¯ ìƒˆë¡œìš´ Target Group: $NEW_TARGET_GROUP"
          echo "ğŸ›‘ ê¸°ì¡´ ìš´ì˜ ASG: $OLD_ASG"
          echo "ğŸ“Œ ë°°í¬í•  ì´ë¯¸ì§€ íƒœê·¸: $DEPLOY_ENV"

      # ì´ë¯¸ì§€ í‘¸ì‹œ
      - name: Build and Push Docker Image to Blue
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-2.amazonaws.com
          ECR_REPOSITORY: gangazido-backend
        run: |
          IMAGE_TAG=$(echo "${DEPLOY_ENV}" | tr '[:upper:]' '[:lower:]')

          echo "ğŸ³ Building Docker image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          if [[ -z "$IMAGE_TAG" ]]; then
            echo "ğŸš¨ IMAGE_TAG ê°’ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤!"
            exit 1
          fi

          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

        # 1. Green í™˜ê²½ ìŠ¤ì¼€ì¼ ì—… ë° í—¬ìŠ¤ì²´í¬ ì¤€ë¹„
      - name: Scale Up Temporary (Green) Auto Scaling Group (${{ env.NEW_ASG }})
        run: |
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${{ env.NEW_ASG }} \
            --desired-capacity 4 --min-size 4 --max-size 5

      - name: Start Green ASG Instance Refresh
        run: |
          STATUS=$(aws autoscaling describe-instance-refreshes --auto-scaling-group-name $NEW_ASG \
            --query 'InstanceRefreshes[0].Status' --output text 2>/dev/null || echo "None")

          if [[ "$STATUS" == "InProgress" ]]; then
            echo "ğŸš¨ í˜„ì¬ ASG($NEW_ASG)ì˜ ì¸ìŠ¤í„´ìŠ¤ ë¦¬í”„ë ˆì‹œê°€ ì´ë¯¸ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ëŒ€ê¸°í•©ë‹ˆë‹¤."
            exit 0
          fi

          echo "ğŸ”„ Green ASG($NEW_ASG) ì¸ìŠ¤í„´ìŠ¤ ë¦¬í”„ë ˆì‹œ ì‹œì‘"
          aws autoscaling start-instance-refresh --auto-scaling-group-name $NEW_ASG

      - name: Wait Until Green ASG is Healthy (ASG + ALB Health Check)
        run: |
          MAX_WAIT=720
          INTERVAL=10
          ELAPSED=0

          echo "â³ Green ASG($NEW_ASG)ì˜ ì¸ìŠ¤í„´ìŠ¤ ë¦¬í”„ë ˆì‹œ ìƒíƒœ + ALB í—¬ìŠ¤ì²´í¬ + ì•± ìƒíƒœ í™•ì¸ ì¤‘..."

          DEPLOY_ENV_LOWER=$(echo "$DEPLOY_ENV" | tr '[:upper:]' '[:lower:]')
          if [[ "$DEPLOY_ENV_LOWER" == "blue" ]]; then
            TG_SUFFIX="prod"
          elif [[ "$DEPLOY_ENV_LOWER" == "green" ]]; then
            TG_SUFFIX="dev"
          else
            echo "âŒ ìœ íš¨í•˜ì§€ ì•Šì€ DEPLOY_ENV: $DEPLOY_ENV"
            exit 1
          fi

          TG_NAME="gangazido-${TG_SUFFIX}-target-group"
          echo "âœ… ë§¤í•‘ëœ Target Group ì´ë¦„: $TG_NAME"

          TG_ARN=$(aws elbv2 describe-target-groups \
            --names $TG_NAME \
            --query 'TargetGroups[0].TargetGroupArn' --output text)

          while true; do
            # ì¸ìŠ¤í„´ìŠ¤ ID ì¡°íšŒ
            INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $NEW_ASG \
              --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
              --output text)
            INSTANCE_COUNT=$(echo $INSTANCE_IDS | wc -w)

            if [[ "$INSTANCE_COUNT" -lt "$EXPECTED_INSTANCE_COUNT" ]]; then
              echo "ğŸ•’ ì¸ìŠ¤í„´ìŠ¤ê°€ ì¶©ë¶„íˆ ìƒì„±ë  ë•Œê¹Œì§€ ëŒ€ê¸° ì¤‘..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              continue
            fi

            # ì¸ìŠ¤í„´ìŠ¤ í¼ë¸”ë¦­ IP ì¡°íšŒ
            echo "ğŸ’¡ ì¸ìŠ¤í„´ìŠ¤ IP ì¡°íšŒ ì¤‘..."
            declare -A INSTANCE_IPS
            for INSTANCE_ID in $INSTANCE_IDS; do
              IP=$(aws ec2 describe-instances \
                --instance-ids $INSTANCE_ID \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text)
              INSTANCE_IPS["$INSTANCE_ID"]=$IP
            done

            # ALB Target ìƒíƒœ í™•ì¸
            HEALTH_STATUSES=$(aws elbv2 describe-target-health \
              --target-group-arn "$TG_ARN" \
              --query 'TargetHealthDescriptions[*].TargetHealth.State' \
              --output text | tr '\n' ' ' | xargs)
            echo "í˜„ì¬ ALB íƒ€ê²Ÿ ìƒíƒœë“¤: $HEALTH_STATUSES"

            if [[ "$HEALTH_STATUSES" != *"unhealthy"* && "$HEALTH_STATUSES" != *"initial"* ]]; then
              echo "âœ… ëª¨ë“  ALB ëŒ€ìƒ ì¸ìŠ¤í„´ìŠ¤ê°€ healthy ìƒíƒœì…ë‹ˆë‹¤."

              # ì•± ìƒíƒœ í™•ì¸
              APP_STATUS_OK=true
              for INSTANCE_ID in $INSTANCE_IDS; do
                IP=${INSTANCE_IPS[$INSTANCE_ID]}
                echo "ğŸ” ì¸ìŠ¤í„´ìŠ¤ $INSTANCE_ID ($IP)ì˜ /actuator/health í™•ì¸ ì¤‘..."

                STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 https://api.gangazido.com/actuator/health)

                if [[ "$STATUS_CODE" != "200" ]]; then
                  echo "âŒ ì¸ìŠ¤í„´ìŠ¤ $INSTANCE_ID ìƒíƒœ ì½”ë“œ: $STATUS_CODE"
                  APP_STATUS_OK=false
                else
                  echo "âœ… ì¸ìŠ¤í„´ìŠ¤ $INSTANCE_ID ìƒíƒœ OK"
                fi
              done

              ASG_STATUS=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name $NEW_ASG \
                --query 'InstanceRefreshes[0].Status' \
                --output text 2>/dev/null || echo "None")

              if [[ "$APP_STATUS_OK" == true && "$ASG_STATUS" == "Successful" ]]; then
                echo "ğŸ‰ ëª¨ë“  ì¡°ê±´ì„ ë§Œì¡±í–ˆìŠµë‹ˆë‹¤. ë°°í¬ ì„±ê³µ!"
                break
              fi
            fi

            if [[ "$ELAPSED" -ge "$MAX_WAIT" ]]; then
              echo "ğŸš¨ íƒ€ì„ì•„ì›ƒ: $MAX_WAITì´ˆ ì•ˆì— ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
              exit 1
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

      - name: Gradually Shift Traffic to New Environment
        run: |
          echo "ğŸ” ì¡°ê±´ë¶€ ê·œì¹™ì˜ Rule ARNì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘..."
          RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn ${{ secrets.ALB_LISTENER_ARN }} \
            --query 'Rules[?Conditions[?Field==`host-header`]].RuleArn' \
            --output text)

          if [[ -z "$RULE_ARN" ]]; then
            echo "ğŸš¨ ERROR: ì¡°ê±´ë¶€ Rule ARNì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
            exit 1
          fi

          echo "ğŸ¯ Rule ARN: $RULE_ARN"

          if [[ -z "$NEW_TARGET_GROUP" || -z "$OLD_ASG_TARGET_GROUP" ]]; then
            echo "ğŸš¨ ERROR: Target Group ARN ê°’ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤."
            exit 1
          fi

          echo "ğŸ”„ ALB íŠ¸ë˜í”½ì„ ì ˆë°˜ì”© ë‚˜ëˆ„ì–´ ìƒˆ í™˜ê²½ìœ¼ë¡œ ì „í™˜ ì¤‘..."

          aws elbv2 modify-rule \
            --rule-arn ${{ env.RULE_ARN }} \
            --actions '[
              {
                "Type": "forward",
                "ForwardConfig": {
                  "TargetGroups": [
                    { "TargetGroupArn": "'"$NEW_TARGET_GROUP"'", "Weight": 50 },
                    { "TargetGroupArn": "'"$OLD_TARGET_GROUP"'", "Weight": 50 }
                  ]
                }
              }
            ]' || { echo "ğŸš¨ [ERROR] íŠ¸ë˜í”½ ë³€ê²½ ì‹¤íŒ¨ (ì ˆë°˜ ì „í™˜ ì‹¤íŒ¨)"; exit 1; }

          echo "âœ… ì ˆë°˜ì”© íŠ¸ë˜í”½ ë¶„ì‚° ì™„ë£Œ!"

          echo "â³ 30ì´ˆ ëŒ€ê¸° í›„ ë‹¤ìŒ ë‹¨ê³„ ì§„í–‰..."
          sleep 30

      - name: Fully Shift Traffic to New Environment
        run: |
          echo "ğŸ” ì¡°ê±´ë¶€ ê·œì¹™ì˜ Rule ARNì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘..."
          RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn ${{ secrets.ALB_LISTENER_ARN }} \
            --query 'Rules[?Conditions[?Field==`host-header`]].RuleArn' \
            --output text)

          if [[ -z "$RULE_ARN" ]]; then
            echo "ğŸš¨ ERROR: ì¡°ê±´ë¶€ Rule ARNì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
            exit 1
          fi

          if [[ -z "$NEW_TARGET_GROUP" ]]; then
            echo "ğŸš¨ ERROR: NEW_TARGET_GROUP ê°’ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤."
            exit 1
          fi
          echo "ğŸš€ ALB íŠ¸ë˜í”½ì„ ì™„ì „íˆ ìƒˆ í™˜ê²½($NEW_TARGET_GROUP)ìœ¼ë¡œ ì „í™˜ ì¤‘..."

          aws elbv2 modify-rule \
            --rule-arn "$RULE_ARN" \
            --actions '[
              {
                "Type": "forward",
                "ForwardConfig": {
                  "TargetGroups": [
                    {
                      "TargetGroupArn": "'"$NEW_TARGET_GROUP"'",
                      "Weight": 100
                    }
                  ]
                }
              }
            ]' || { echo "ğŸš¨ [ERROR] ìµœì¢… íŠ¸ë˜í”½ ë³€ê²½ ì‹¤íŒ¨"; exit 1; }

            echo "âœ… íŠ¸ë˜í”½ì´ ì™„ì „íˆ ìƒˆë¡œìš´ í™˜ê²½ìœ¼ë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤."

      - name: Scale Down New ASG
        run: |
          echo "âœ… Green ASG($NEW_ASG)ë¥¼ ì¶•ì†Œí•©ë‹ˆë‹¤."
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${{ env.NEW_ASG }} \
            --desired-capacity 2 --min-size 2 --max-size 5
#ë¸”ë£¨ ì´ë¯¸ì§€ ìƒì„± í™•ì¸
